"""
Parameter definitions and bounds for evolutionary optimization.

Each parameter has:
- min/max: Bounds for the parameter
- step: Step size for mutations (or 'power_of_2' for special handling)
- default: Starting value
"""

from dataclasses import dataclass
from typing import Dict, Any, Literal

@dataclass
class ParamBounds:
    """Defines bounds and mutation behavior for a parameter."""
    min: int
    max: int
    step: int | Literal["power_of_2"]
    default: int
    description: str

# Parameter space for evolutionary optimization
# Starting with 6 key parameters that have significant performance impact
PARAM_BOUNDS: Dict[str, ParamBounds] = {
    "num_shards": ParamBounds(
        min=4,
        max=64,
        step="power_of_2",
        default=16,
        description="Number of shards for data partitioning (power of 2)"
    ),
    "response_pool.capacity": ParamBounds(
        min=64,
        max=1024,
        step=64,
        default=256,
        description="Maximum response slots in pool"
    ),
    "response_pool.prewarm": ParamBounds(
        min=16,
        max=256,
        step=16,
        default=64,
        description="Pre-allocated response slots at startup"
    ),
    "buffers.read_size": ParamBounds(
        min=4096,
        max=32768,
        step=4096,
        default=8192,
        description="Read buffer size in bytes"
    ),
    "batching.min_pipeline_buffer": ParamBounds(
        min=30,
        max=200,
        step=10,
        default=60,
        description="Minimum buffer size to attempt batching"
    ),
    "batching.batch_threshold": ParamBounds(
        min=2,
        max=8,
        step=1,
        default=2,
        description="Minimum commands to trigger batch execution"
    ),
}

# Default configuration (starting point for evolution)
DEFAULT_CONFIG: Dict[str, int] = {
    param: bounds.default for param, bounds in PARAM_BOUNDS.items()
}

def clamp(value: int, min_val: int, max_val: int) -> int:
    """Clamp value to bounds."""
    return max(min_val, min(max_val, value))

def is_power_of_two(n: int) -> bool:
    """Check if n is a power of 2."""
    return n > 0 and (n & (n - 1)) == 0

def next_power_of_two(n: int, direction: int) -> int:
    """Get next power of 2 in given direction (-1 or 1)."""
    if direction > 0:
        return n * 2
    else:
        return n // 2

def validate_config(config: Dict[str, int]) -> bool:
    """Validate that all config values are within bounds."""
    for param, value in config.items():
        if param not in PARAM_BOUNDS:
            return False
        bounds = PARAM_BOUNDS[param]
        if value < bounds.min or value > bounds.max:
            return False
        if bounds.step == "power_of_2" and not is_power_of_two(value):
            return False
    return True

def config_to_toml(config: Dict[str, int]) -> str:
    """Convert config dict to TOML format matching perf_config.toml structure."""
    lines = [
        "# Performance Configuration (generated by evolve harness)",
        f"num_shards = {config['num_shards']}",
        "",
        "[response_pool]",
        f"capacity = {config['response_pool.capacity']}",
        f"prewarm = {config['response_pool.prewarm']}",
        "",
        "[buffers]",
        f"read_size = {config['buffers.read_size']}",
        "max_size = 1048576  # 1MB (fixed)",
        "",
        "[batching]",
        f"min_pipeline_buffer = {config['batching.min_pipeline_buffer']}",
        f"batch_threshold = {config['batching.batch_threshold']}",
    ]
    return "\n".join(lines)
